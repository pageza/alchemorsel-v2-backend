package api

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/pageza/alchemorsel-v2/backend/internal/models"
	"github.com/pageza/alchemorsel-v2/backend/internal/service"
	"gorm.io/gorm"
)

// DashboardHandler handles dashboard-related requests
type DashboardHandler struct {
	db          *gorm.DB
	authService service.IAuthService
}

// NewDashboardHandler creates a new DashboardHandler
func NewDashboardHandler(db *gorm.DB, authService service.IAuthService) *DashboardHandler {
	return &DashboardHandler{
		db:          db,
		authService: authService,
	}
}

// RegisterRoutes registers the dashboard routes
func (h *DashboardHandler) RegisterRoutes(router *gin.RouterGroup) {
	dashboard := router.Group("/dashboard")
	{
		dashboard.GET("/stats", h.GetStats)
		dashboard.GET("/favorites/recent", h.GetRecentFavorites)
	}
}

// DashboardStats represents dashboard statistics
type DashboardStats struct {
	RecipesGenerated int    `json:"recipesGenerated"`
	Favorites        int    `json:"favorites"`
	ThisWeek         int    `json:"thisWeek"`
	PrimaryDiet      string `json:"primaryDiet"`
}

// GetStats returns dashboard statistics for the current user
func (h *DashboardHandler) GetStats(c *gin.Context) {
	userIDVal, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
		return
	}

	userID, ok := userIDVal.(uuid.UUID)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user ID"})
		return
	}

	// Get user's primary dietary preference
	primaryDiet := h.getPrimaryDiet(userID)

	// Get actual statistics from database
	recipesGenerated, err := h.getRecipesGenerated(userID)
	if err != nil {
		recipesGenerated = 0 // Fallback to 0 on error
	}

	favoritesCount, err := h.getFavoritesCount(userID)
	if err != nil {
		favoritesCount = 0 // Fallback to 0 on error
	}

	thisWeekCount, err := h.getThisWeekCount(userID)
	if err != nil {
		thisWeekCount = 0 // Fallback to 0 on error
	}

	stats := DashboardStats{
		RecipesGenerated: recipesGenerated,
		Favorites:        favoritesCount,
		ThisWeek:         thisWeekCount,
		PrimaryDiet:      primaryDiet,
	}

	c.JSON(http.StatusOK, stats)
}

// getPrimaryDiet retrieves the user's primary dietary preference
func (h *DashboardHandler) getPrimaryDiet(userID uuid.UUID) string {
	var user models.User
	err := h.db.Preload("DietaryPrefs").Where("id = ?", userID).First(&user).Error
	if err != nil {
		// Return empty string if user not found or has no dietary preferences
		return ""
	}

	// Extract dietary preferences following the same pattern as LLM handler
	var dietaryPrefs []string
	for _, pref := range user.DietaryPrefs {
		if pref.PreferenceType != "" {
			dietaryPrefs = append(dietaryPrefs, pref.PreferenceType)
		} else if pref.CustomName != "" {
			dietaryPrefs = append(dietaryPrefs, pref.CustomName)
		}
	}

	// Return the first dietary preference as primary, or empty if none
	if len(dietaryPrefs) > 0 {
		return dietaryPrefs[0]
	}

	return ""
}

// getRecipesGenerated counts the total number of recipes generated by the user
func (h *DashboardHandler) getRecipesGenerated(userID uuid.UUID) (int, error) {
	var count int64
	err := h.db.Model(&models.Recipe{}).Where("user_id = ?", userID).Count(&count).Error
	return int(count), err
}

// getFavoritesCount counts the number of recipes the user has favorited
func (h *DashboardHandler) getFavoritesCount(userID uuid.UUID) (int, error) {
	var count int64
	err := h.db.Model(&models.RecipeFavorite{}).Where("user_id = ?", userID).Count(&count).Error
	return int(count), err
}

// getThisWeekCount counts recipes generated this week
func (h *DashboardHandler) getThisWeekCount(userID uuid.UUID) (int, error) {
	// Calculate start of this week (Sunday)
	now := time.Now()
	weekday := int(now.Weekday())
	if weekday == 0 {
		weekday = 7 // Make Sunday = 7 instead of 0
	}
	startOfWeek := now.AddDate(0, 0, -weekday+1).Truncate(24 * time.Hour)

	var count int64
	err := h.db.Model(&models.Recipe{}).
		Where("user_id = ? AND created_at >= ?", userID, startOfWeek).
		Count(&count).Error
	return int(count), err
}

// GetRecentFavorites returns recent favorite recipes for the current user
func (h *DashboardHandler) GetRecentFavorites(c *gin.Context) {
	_, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
		return
	}

	// TODO: Implement actual favorites query
	// For now, return empty array to prevent frontend errors
	c.JSON(http.StatusOK, []interface{}{})
}
